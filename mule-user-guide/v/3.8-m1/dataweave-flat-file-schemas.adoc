= DataWeave Flatfile Schemas
:keywords: b2b, edi, schema, dataweave, yaml, language, reference

link:/mule-user-guide/v/3.8-m1/dataweave[DataWeave] allows you to process several different types of data. For most of these types, you can link:/mule-user-guide/v/3.8-m1/using-dataweave-in-studio#defining-input-and-output-structure[import a schema] that describes the input structure in order to have access to valuable metadata at design time. DataWeave uses a YAML format called FFD (for Flat File Definition) to represent flat file schemas. The FFD format is very flexible to support a range of use cases, but is based around the concepts of elements, composites, segments and structures.

* *element* - an element is a basic data item, which has an associated type and fixed width, along with formatting options for how the data value is read and written
* *composite* - a group of elements and/or composites which are used together
* *segment* - a line of data, made up of any number of elements and/or composites which may be repeated
* *structure* - a hierarchical organization of segments, which requires that the segments have unique identifier codes as part of their data

If you are only working with one type of record, you only need to have a segment definition for that record type in your FFD. If you're working with multiple types of records in the same transform, you'll need to use a structure definition that controls how these different records are combined.

If you have a single structure or segment definition in an FFD, that structure or segment definition will be used automatically whenever you use the FFD as metadata for a link:/mule-user-guide/v/3.8-m1/dataweave[DataWeave] transformer. If you have multiple structures or segment definitions in an FFD you'll need to specify which one you want to use for each DataWeave transform.


Schemas must be written in Flat File Schema Language, with a .ffs extension. This language is very similar to EDI Schema Language (ESL), which is also accepted by the Studio component.

== Top-level structure of an FFD Document


The top-level definition in an FFD document starts with the form of the schema, in this case it must always be "FLATFILE" ("COPYBOOK" and "FIXEDWIDTH" are treated as synonyms for "FLATFILE"). The rest depends on the form of definitions present in the file, with the following alternatives:

* *multiple structures* - a _structures_ key with multiple child objects, each defining one structure
* *single structure* - structure information directly at the top level (including a _data_ key giving the segment details of the structure)
* *multiple segments* - a _segments_ key with multiple child objects, each defining one segment
* *single segment* - segment information directly at the top level (including a _values_ key giving the element and/or composite details of the segment)

By way of example, here's what the top-level structure of a schema with multiple structures might look like:

[source,yaml, linenums]
----
form: FIXEDWIDTH
structures:
- id: 'BatchReq'
  name: Batch Request
  tagStart: 0
  tagLength: 1
  data:
  - { idRef: 'RQH' }
  - groupId: 'Batch'
    usage: O
    count: '>1'
    items:
    - { idRef: 'BCH' }
    - { idRef: 'TDR', count: '>1' }
    - { idRef: 'BCF' }
  - { idRef: 'RQF' }
- id: 'BatchRsp'
  name: Batch Response
  tagStart: 0
  tagLength: 1
  data:
  - { idRef: 'RSH' }
  - groupId: 'Batch'
    usage: O
    count: '>1'
    items:
    - { idRef: 'BCH' }
    - { idRef: 'TDR', count: '>1' }
    - { idRef: 'BCF' }
  - { idRef: 'RSF' }
  …
----

The above defines two different structures, the *BatchReq* structure and the *BatchRsp* structure. Each of these structures uses a particular sequence of records (or segments), with some of the records repeating. If this schema only included one of the structures, say the *BatchReq* structure, it could instead use the simpler form:

[source,yaml, linenums]
----
form: FLATFILE
id: 'BatchReq'
name: Batch Request
tagStart: 0
tagLength: 1
data:
- { idRef: 'RQH' }
- groupId: 'Batch'
  usage: O
  count: '>1'
  items:
  - { idRef: 'BCH' }
  - { idRef: 'TDR', count: '>1' }
  - { idRef: 'BCF' }
- { idRef: 'RQF' }
…
----

Likewise, here's an example of a multiple-segment schema:

[source,yaml, linenums]
----
form: FLATFILE
segments:
- id: 'RQH'
  tag: '1'
  name: Request Header Record
  values:
  - { idRef: 'OrgCode' }
  - { idRef: 'CreatDate' }
  - { idRef: 'CreatTime' }
  - { idRef: 'EntityName' }
  - { idRef: 'FileId' }
  - { idRef: 'Filler1', usage: U }
- id: 'RSH'
  tag: '1'
  name: Response Header Record
  values:
  - { idRef: 'OrgCode' }
  - { idRef: 'EntityName' }
  - { idRef: 'FileId' }
  - { idRef: 'Filler2', usage: U }
- id: 'BCH'
  tag: '2'
  name: Batch Header Record
  values:
  - { idRef: 'CompName' }
  - { idRef: 'CompCode' }
  - { idRef: 'BatchType' }
  - { idRef: 'BatchDesc' }
  - { idRef: 'BatchId' }
  - { idRef: 'RefundFlag' }
  - { idRef: 'Currency' }
  - { idRef: 'Filler3', usage: U }
…
----

And here's a simplified form with only one segment:

[source,yaml, linenums]
----
form: FLATFILE
id: 'RQH'
tag: '1'
name: Request Header Record
values:
- { idRef: 'OrgCode' }
- { idRef: 'CreatDate' }
- { idRef: 'CreatTime' }
- { idRef: 'EntityName' }
- { idRef: 'FileId' }
- { idRef: 'Filler1', usage: U }
…
----

[TIP]
The simplified forms are only for convenience. You can use the _structures_ key even if you only have a single child structure definition, and you can use the _segments_ key even if you only have a single child segment definition.


== References and in-lined definitions

Besides the choice of top-level form, you also have choices when it comes to representing the components of a structure, segment, or composite. You can define the component segments, composites, and elements inline, at the point of use, or you can define them in a table and reference them from anywhere. Inlining definitions is simpler and more compact, but the table form allows definitions to be reused. The examples shown in the last section all are based on the table form, where each definition includes an _id_ value and each reference to that definition uses an _idRef_. Here's an example that shows how this applies to the segments making up a structure:

[source,yaml, linenums]
----
form: FIXEDWIDTH
structures:
- id: 'BatchReq'
  name: Batch Request
  tagStart: 0
  tagLength: 1
  data:
  - { idRef: 'RQH' }
  - groupId: 'Batch'
    usage: O
    count: '>1'
    items:
    - { idRef: 'BCH' }
    - { idRef: 'TDR', count: '>1' }
    - { idRef: 'BCF' }
  - { idRef: 'RQF' }
...
segments:
- id: 'RQH'
  tag: '1'
  name: Request Header Record
  values:
  - { idRef: 'OrgCode' }
  - { idRef: 'CreatDate' }
  - { idRef: 'CreatTime' }
  ...
- id: 'BCH'
  tag: '2'
  name: Batch Header Record
  values:
  - { idRef: 'CompName' }
  - { idRef: 'CompCode' }
  - { idRef: 'BatchType' }
  ...
- id: 'TDR'
  tag: '3'
  name: Transaction Detail Record
  values:
  - { idRef: 'ExpDate' }
  - { idRef: 'AcctNum' }
  - { idRef: 'Amount' }
  - { idRef: 'CustNum' }
  - { idRef: 'CustAcct' }
  - { idRef: 'TransNum' }
  ...
- id: 'BCF'
  tag: '4'
  name: Batch Footer Record
  values:
  - { idRef: 'BatchTransCount' }
  - { idRef: 'BatchTransAmount' }
  ...
- id: 'RQF'
  tag: '5'
  name: Request Footer Record
  values:
  - { idRef: 'FileBatchCount' }
  - { idRef: 'FileTransCount' }
  - { idRef: 'FileTransAmount' }
  ...
elements:
  - { id: 'OrgCode', name: 'Organization Code', type: String, length: 10 }
  - { id: 'CreatDate', name: 'File Creation Date', type: Date, length: 8 }
  - { id: 'CreatTime', name: 'File Creation Time', type: Time, length: 4 }
  - { id: 'CompName', name: 'Company Name', type: String, length: 30 }
  - { id: 'CompCode', name: 'Company Code', type: String, length: 10 }
  - { id: 'BatchType', name: 'Batch Type', type: String, length: 2 }
  - { id: 'ExpDate', name: 'Expiration Date', type: String, length: 8 }
  - { id: 'AcctNum', name: 'Account Number', type: String, length: 17 }
  - { id: 'Amount', name: 'Amount', type: Integer, format: { justify: zeroes }, length: 10 }
  - { id: 'CustNum', name: 'Customer Number', type: String, length: 15 }
  - { id: 'CustAcct', name: 'Customer Account Name', type: String, length: 22 }
  - { id: 'TransNum', name: 'Transaction Number', type: String, length: 15 }
  - { id: 'BatchTransCount', name: 'Batch Transaction Count', type: Integer, format: { justify: zeroes }, length: 6 }
  - { id: 'BatchTransAmount', name: 'Batch Transaction Amount', type: Integer, format: { justify: zeroes }, length: 10 }
  - { id: 'FileBatchCount', name: 'File Batch Count', type: Integer, format: { justify: zeroes }, length: 2 }
  - { id: 'FileTransCount', name: 'File Transaction Count', type: Integer, format: { justify: zeroes }, length: 8 }
  - { id: 'FileTransAmount', name: 'File Transaction Amount', type: Integer, format: { justify: zeroes }, length: 12 }
…
----

In the above example, the *BatchReq* structure references segments in the _data_ definition section. The segments are defined in the _segments_ section at the top level of the schema, and in turn reference elements in the _values_ definition sections. The elements are defined in the _elements_ section, again at the top level of the schema.

Here's what a partial in-lined definition of the same structure would look like:

[source,yaml, linenums]
----
form: FIXEDWIDTH
structures:
- id: 'BatchReq'
  name: Batch Request
  tagStart: 0
  tagLength: 1
  data:
  - id: 'RQH'
    tag: '1'
    name: Request Header Record
    values:
    - { name: 'Organization Code', type: String, length: 10 }
    - { name: 'File Creation Date', type: Date, length: 8 }
    - { name: 'File Creation Time', type: Time, length: 4 }
  - groupId: 'Batch'
    usage: O
    count: '>1'
    items:
    - id: 'BCH'
      tag: '2'
      name: Batch Header Record
      values:
      - { name: 'Company Name', type: String, length: 30 }
      - { name: 'Company Code', type: String, length: 10 }
      - { name: 'Batch Type', type: String, length: 2 }
    - id: 'TDR'
      tag: '3'
      name: Transaction Detail Record
      values:
      - { name: 'Expiration Date', type: String, length: 8 }
      - { name: 'Account Number', type: String, length: 17 }
      - { name: 'Amount', type: Integer, format: { justify: zeroes }, length: 10 }
      ...
----


== Element Definitions

Element definitions are the basic building blocks of application data, consisting of basic key-value pairs for standard characteristics. Here are several element definitions:

[source,yaml, linenums]
----
  - { id: 'OrgCode', name: 'Organization Code', type: String, length: 10 }
  - { id: 'CreatDate', name: 'File Creation Date', type: Date, length: 8 }
  - { id: 'CreatTime', name: 'File Creation Time', type: Time, length: 4 }
  - { id: 'BatchTransCount', name: 'Batch Transaction Count', type: Integer, format: { justify: zeroes }, length: 6 }
  - { id: 'BatchTransAmount', name: 'Batch Transaction Amount', type: Integer, format: { justify: zeroes }, length: 10 }
----

Element definition values are:

[width="100%",cols="50%,50%",options="header",]
|===
|Name |Description
|id |Element identifier (unused for inline definitions, required for definitions in table form)
|name |Element name (optional)
|type |Value type code, as listed below
|format |type-specific formatting information
|length |Number of columns for value
|===

Value types used in element definitions are:

[cols=",",options="header",]
|===
|Name |Description
|Boolean |Boolean value
|Date |Unzoned date value with year, month, and day components (which may not all be shown in text form)
|DateTime |Unzoned date/time value with year, month, day, hour, minute, second, and millisecond components (which may not all be shown in text form)
|Decimal |Decimal number value, which may or may not include an explicit decimal point in text form
|Integer |Integer number value
|PackedDecimal |Packed decimal representation of a decimal number value
|Time |Unzoned time value with hour, minute, second, and millisecond components (which may not all be shown in text form)
|String |String value
|===

Value types support a range of format options that effect the text form of the values. Here are the main options, along with the types they apply to:


[cols=",",options="header",]
|===
|Key |Description |Applies to
|implicit |Implicit number of decimal digits (used for fixed-point values with no decimal in text form) |Decimal
|justify |Justification in field (LEFT, RIGHT, NONE, or ZEROES, the last only for numbers) |All except PackedDecimal
|pattern |For numeric values, the java.text.DecimalFormat pattern for parsing and writing; for date/time values, the java.time.format.DateTimeFormatter pattern |Date, DateTime, Decimal, Integer, Time
|sign |Sign usage for numeric values (UNSIGNED, NEGATIVE_ONLY, OPTIONAL, ALWAYS_LEFT, ALWAYS_RIGHT) |Decimal, Integer
|===


== Composite Definitions

Composite definitions are very similar to segment definitions, again composed of some key-value pairs for standard characteristics along with lists of values (elements and composites) making up the actual composite. Here's a sample of a composite definition:

[source,yaml, linenums]
----
- id: 'DateTime'
  name: 'Date/Time pair'
  values:
  - { idRef: 'CreatDate' }
  - { idRef: 'CreatTime' }
----

Composite definition values are:

[cols=",",options="header",]
|===
|Name |Description
|id |Composite identifier (unused for inline definitions, required for definitions in table form)
|name |Composite name (optional)
|values |List of elements and composites within the composite
|===

The values list takes the same form as the values list in a segment definition.


== Segment Definitions

Segment definitions are again composed of some key-value pairs for standard characteristics along with lists of values (elements and composites) making up the actual segment. Here's a portion of a sample segment definition:

[source,yaml, linenums]
----
- id: 'RQH'
  tag: '1'
  name: Request Header Record
  values:
  - { idRef: 'OrgCode' }
  - { idRef: 'CreatDate' }
  - { idRef: 'CreatTime' }
----

Segment definition values are:

[cols=",",options="header",]
|===
|Section |Description
|id |Segment identifier (unused for inline definitions, required for definitions in table form)
|tag |Unique identifier tag for segment (ignored if using segments directly, rather than as part of a structure)
|name |Segment name (optional)
|values |List of elements and composites within the segment
|===

The values field may either give definitions inline or list references, elements and composites by their ids (shown using a compact YAML syntax where the values for each reference are given as comma-separated key-value pairs enclosed in curly braces). The values used with references are:

[cols=",",options="header",]
|===
|Section |Description
|idRef |The referenced element or composite id
|name |The name of the value in the segment (optional, element or composite name used by default)
|usage |Usage code, which may be M for Mandatory, O for Optional, or U for Unused (__likely to change for release__) (optional, Mandatory assumed if not specified)
|count |Maximum repetition count value, which may be any number or the special value '>1' meaning any number of repeats (optional, count value of 1 is used if not specified)
|===

Inline value definitions use the _name_, _usage_, and _count_ key-value pairs from the reference form, combined with the composite or element key-value pairs defined below.

== Structure definitions

Structure definitions are composed of a set of key-value pairs for standard characteristics along with lists of segments (or segment references) making up the actual structure. Segments may be further organized into groups consisting of a potentially repeated sequence of segments.

Here's a sample structure definition again:

[source,yaml, linenums]
----
- id: 'BatchReq'
  name: Batch Request
  tagStart: 0
  tagLength: 1
  data:
  - { idRef: 'RQH' }
  - groupId: 'Batch'
    usage: O
    count: '>1'
    items:
    - { idRef: 'BCH' }
    - { idRef: 'TDR', count: '>1' }
    - { idRef: 'BCF' }
  - { idRef: 'RQF' }
  …
----

The basic structure values are:

[cols=",",options="header",]
|===
|Structure Key/Section |Description
|id |Structure identifier
|name |Structure name (optional)
|tagStart |Starting column number for segment identifier tags (unique values associated with each segment in a structure)
|tagLength |Number of columns in segment identifier tags
|data |List of segments (and groups) in the structure
|===

Each item in a segment list is either a segment reference (or inline definition) or a group definition (always inline). Segment references are shown using a compact YAML syntax where the values for each reference are given as comma-separated key-value pairs enclosed in curly braces. The values are:

[width="100%",cols="50%,50%",options="header",]
|===
|Segment Property |Description
|idRef |The referenced segment id
|usage |Usage code, which may be M for Mandatory, O for Optional, or U for Unused (__likely to change for release__) (optional, Mandatory assumed if not specified)
|count |Maximum repetition count value, which may be a number or the special value '>1' meaning any number of repeats (optional, count value of 1 is used by default)
|===

Inline segment definitions use the _usage_ and _count_ key-value pairs as for references, but combine these with the segment definition key-value pairs described below.

Group definitions are shown in expanded form, with key-value pairs on separate lines. The values in a group definition are:

[cols=",",options="header",]
|===
|Value| Description
|groupId |The group identifier
|usage |Usage code, which may be M for Mandatory, O for Optional, or U for Unused (optional, defaults to M)
|count |Maximum repetition count value, which may be a number or the special value '>1' meaning any number of repeats (optional, count value of 1 is used if not specified)
|items |List of segments (and potentially nested groups) making up the group
|===
